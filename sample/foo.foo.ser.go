package sample

import (
	"errors"
	"fmt"
	"github.com/JustBeYou/serialize/decoders"
	"github.com/JustBeYou/serialize/encoders"
	"github.com/JustBeYou/serialize/standard"
)

// THIS FILE WAS GENERATED BY serialize
// PLEASE DO NOT EDIT

func (self Foo) HashingSerialize() ([]byte, error) {
	var output, bytesTemp []byte
	var tempHeader standard.FieldHeader
	var tempLen uint64

	bytesTemp = encoders.IntAsBytes(self.Bar)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.UintAsBytes(self.Fizz)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.StringAsBytes(self.Buzz)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.BoolAsBytes(self.FizzBuzz)
	output = append(output, bytesTemp...)

	tempLen = uint64(len(self.BarArray))
	tempHeader = standard.NewArrayHeader(tempLen)
	bytesTemp, _ = tempHeader.Serialize()

	if tempHeader.Is16BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint16AsBytes(uint16(tempLen))...)
	} else if tempHeader.Is32BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint32AsBytes(uint32(tempLen))...)
	} else if tempHeader.Is64BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint64AsBytes(uint64(tempLen))...)
	} else {
		bytesTemp = append(bytesTemp, encoders.Uint8AsBytes(uint8(tempLen))...)
	}
	for _, v := range self.BarArray {
		bytesTemp = append(bytesTemp, encoders.BoolAsBytes(v)...)
	}
	output = append(output, bytesTemp...)

	bytesTemp, _ = self.Custom.HashingSerialize()
	output = append(output, bytesTemp...)
	return output, nil
}
func (self Foo) HashingUnserialize(data []byte) (interface{}, uint64, error) {
	var output Foo
	var index uint64 = 0
	var consumed uint64 = 0
	var err error
	var tempHeader standard.FieldHeader
	var tempLen uint64
	var tempCustom interface{}

	output.Bar, consumed, err = decoders.IntFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.Fizz, consumed, err = decoders.UintFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.Buzz, consumed, err = decoders.StringFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.FizzBuzz, consumed, err = decoders.BoolFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	tempHeader, err = standard.FieldHeaderFromBytes(data[index])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += 1

	if tempHeader.Is16BitSize {
		var tempLen2 uint16
		tempLen2, consumed, err = decoders.Uint16FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else if tempHeader.Is32BitSize {
		var tempLen2 uint32
		tempLen2, consumed, err = decoders.Uint32FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else if tempHeader.Is64BitSize {
		var tempLen2 uint64
		tempLen2, consumed, err = decoders.Uint64FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else {
		var tempLen2 uint8
		tempLen2, consumed, err = decoders.Uint8FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	}
	index += consumed

	for i := uint64(0); i < tempLen; i++ {
		var tempValue bool
		tempValue, consumed, err = decoders.BoolFromBytes(data[index:])
		output.BarArray = append(output.BarArray, tempValue)
		if err != nil {
			return output, index, errors.New(fmt.Sprintf("Could not decode at %d: %s\n", index, err.Error()))
		}
		index += consumed
	}

	tempCustom, consumed, err = Bar{}.HashingUnserialize(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	output.Custom = tempCustom.(Bar)
	index += consumed
	return output, index, nil
}
func (self Foo) Serialize() ([]byte, error) {
	var output, bytesTemp []byte
	var tempHeader standard.FieldHeader
	var tempLen uint64

	bytesTemp = encoders.IntAsBytes(self.Bar)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.UintAsBytes(self.Fizz)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.StringAsBytes(self.Buzz)
	output = append(output, bytesTemp...)

	bytesTemp = encoders.BoolAsBytes(self.FizzBuzz)
	output = append(output, bytesTemp...)

	tempLen = uint64(len(self.BarArray))
	tempHeader = standard.NewArrayHeader(tempLen)
	bytesTemp, _ = tempHeader.Serialize()

	if tempHeader.Is16BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint16AsBytes(uint16(tempLen))...)
	} else if tempHeader.Is32BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint32AsBytes(uint32(tempLen))...)
	} else if tempHeader.Is64BitSize {
		bytesTemp = append(bytesTemp, encoders.Uint64AsBytes(uint64(tempLen))...)
	} else {
		bytesTemp = append(bytesTemp, encoders.Uint8AsBytes(uint8(tempLen))...)
	}
	for _, v := range self.BarArray {
		bytesTemp = append(bytesTemp, encoders.BoolAsBytes(v)...)
	}
	output = append(output, bytesTemp...)

	bytesTemp = encoders.StringAsBytes(self.Hash)
	output = append(output, bytesTemp...)

	bytesTemp, _ = self.Custom.Serialize()
	output = append(output, bytesTemp...)
	return output, nil
}
func (self Foo) Unserialize(data []byte) (interface{}, uint64, error) {
	var output Foo
	var index uint64 = 0
	var consumed uint64 = 0
	var err error
	var tempHeader standard.FieldHeader
	var tempLen uint64
	var tempCustom interface{}

	output.Bar, consumed, err = decoders.IntFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.Fizz, consumed, err = decoders.UintFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.Buzz, consumed, err = decoders.StringFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	output.FizzBuzz, consumed, err = decoders.BoolFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	tempHeader, err = standard.FieldHeaderFromBytes(data[index])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += 1

	if tempHeader.Is16BitSize {
		var tempLen2 uint16
		tempLen2, consumed, err = decoders.Uint16FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else if tempHeader.Is32BitSize {
		var tempLen2 uint32
		tempLen2, consumed, err = decoders.Uint32FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else if tempHeader.Is64BitSize {
		var tempLen2 uint64
		tempLen2, consumed, err = decoders.Uint64FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	} else {
		var tempLen2 uint8
		tempLen2, consumed, err = decoders.Uint8FromBytes(data[index:])
		tempLen = uint64(tempLen2)
	}
	index += consumed

	for i := uint64(0); i < tempLen; i++ {
		var tempValue bool
		tempValue, consumed, err = decoders.BoolFromBytes(data[index:])
		output.BarArray = append(output.BarArray, tempValue)
		if err != nil {
			return output, index, errors.New(fmt.Sprintf("Could not decode at %d: %s\n", index, err.Error()))
		}
		index += consumed
	}

	output.Hash, consumed, err = decoders.StringFromBytes(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	index += consumed

	tempCustom, consumed, err = Bar{}.Unserialize(data[index:])
	if err != nil {
		return output, index, errors.New(fmt.Sprintf("Could not decode"))
	}
	output.Custom = tempCustom.(Bar)
	index += consumed
	return output, index, nil
}
